% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/s4-CalibrationParam.R
\docType{class}
\name{CalibrationParam-class}
\alias{CalibrationParam-class}
\alias{simulate_dt}
\alias{simulate_adcp}
\alias{simulate_adcp,CalibrationParam-method}
\alias{simulate_adcp,CalibrationParam-methods}
\alias{probability_distribution}
\alias{expected_value}
\alias{expected_value,CalibrationParam-method}
\alias{expected_pcds_equation}
\alias{expected_pcds_equation,CalibrationParam-method}
\alias{expected_cdo_equation}
\alias{expected_cdo_equation,CalibrationParam-method}
\title{Virtual super-class for calibration parameters}
\usage{
simulate_dt(object, ...)

simulate_adcp(object, times, ...)

\S4method{simulate_adcp}{CalibrationParam}(object, times, ...)

probability_distribution(object, times, ...)

expected_value(object, times, ...)

\S4method{expected_value}{CalibrationParam}(
  object,
  times,
  ...,
  method = c("default", "prob", "mc"),
  n_sim = 10000L,
  attrs = NULL,
  .trans_v = NULL,
  .lagg_ev = NULL,
  .simulate_pv = NULL
)

expected_pcds_equation(
  object,
  times,
  discount_factors,
  recovery_rate,
  coupon,
  upfront,
  ...
)

\S4method{expected_pcds_equation}{CalibrationParam}(
  object,
  times,
  discount_factors,
  recovery_rate,
  coupon,
  upfront,
  ...
)

expected_cdo_equation(
  object,
  times,
  discount_factors,
  recovery_rate,
  lower,
  upper,
  coupon,
  upfront,
  ...
)

\S4method{expected_cdo_equation}{CalibrationParam}(
  object,
  times,
  discount_factors,
  recovery_rate,
  lower,
  upper,
  coupon,
  upfront,
  ...
)
}
\arguments{
\item{object}{A \linkS4class{CalibrationParam}-object.}

\item{...}{Pass-through parameters.}

\item{times}{A non-negative numeric vector of timepoints.}

\item{method}{Calculation method (either \code{"default"}, \code{"prob"} (requires implementation of
\code{probability_distribution}), or \code{"mc"}).}

\item{n_sim}{Number of samples.}

\item{attrs}{A named list with functions which are applied to a matrix of \emph{present values}.}

\item{.trans_v}{Internal parameter, not independent for the user.}

\item{.lagg_ev}{Internal parameter, not independent for the user.}

\item{.simulate_pv}{Internal parameter, not independent for the user.}

\item{discount_factors}{Non-negative numeric vector for the discount factors for the timepoints.}

\item{recovery_rate}{Non-negative number between zero and one for the \emph{recovery rate}..}

\item{coupon}{Numeric number for the running coupon.}

\item{upfront}{Numeric number for the upfront payment.}

\item{lower}{Non-negative number between zero and one for the \emph{lower attachment point}.}

\item{upper}{Non-negative number between zero and one for the \emph{upper attachment point}.}
}
\description{
\code{CalibrationParam} provides a simple interface to calculate \emph{expected values}
and \emph{pricing equations} for \emph{portfolio CDS'} and \emph{CDO's} with different
models.
}
\section{Functions}{
\itemize{
\item \code{simulate_dt}: simulates the vector of \emph{default times} and returns a matrix \code{x} with
\code{dim(x) == c(n_sim, getDimension(object))}.

\item \code{simulate_adcp}: simulates the \emph{average default counting process} and returns a
matrix \code{x} with \code{dim(x) == c(n_sim, length(times))}.

\item \code{simulate_adcp,CalibrationParam-method}: simulates the \emph{average default counting process} and returns a
matrix \code{x} with \code{dim(x) == c(n_sim, length(times))}.

\item \code{probability_distribution}: calculates the \emph{probability vector} for the \emph{average default count process}
and returns a matrix \code{x} with \code{dim(x) == c(getDimension(object)+1L, length(times))}.

\item \code{expected_value}: calculates the \emph{expected value} for the loss based on the \emph{average default
count process} for given timepoints and returns a vector \code{x} with
\code{length(x) == length(times)}.

\item \code{expected_value,CalibrationParam-method}: calculates the \emph{expected value} for the loss based on the \emph{average default
count process} for given timepoints and returns a vector \code{x} with
\code{length(x) == length(times)}.

\item \code{expected_pcds_equation}: calculates the \emph{payoff equation} for a \emph{portfolio CDS} (vectorized w.r.t.
the argumentes \code{recovery_rate}, \code{coupon}, and \code{upfront}).

\item \code{expected_pcds_equation,CalibrationParam-method}: calculates the \emph{payoff equation} for a \emph{portfolio CDS} (vectorized w.r.t.
the argumentes \code{recovery_rate}, \code{coupon}, and \code{upfront}).

\item \code{expected_cdo_equation}: calculates the \emph{payoff equation} for a \emph{CDO} (vectorized w.r.t. the
argumentes \code{recovery_rate}, \code{coupon}, and \code{upfront}).

\item \code{expected_cdo_equation,CalibrationParam-method}: calculates the \emph{payoff equation} for a \emph{CDO} (vectorized w.r.t. the
argumentes \code{recovery_rate}, \code{coupon}, and \code{upfront}).
}}

\section{Slots}{

\describe{
\item{\code{dim}}{The dimension (number of portfolio items).}
}}

\section{Probability distribution}{

The probability vector of the \emph{average default counting process} \eqn{L}
for certain times can be calculated with \code{\link[=probability_distribution]{probability_distribution()}};
i.e. the values
\deqn{
  \mathbb{P}(L_t = k/d) , \quad k \in {\{ 0, \ldots, d \}} , \quad t \geq 0 .
}
}

\section{Expected value}{

The \emph{expectated value} of finite linear transformations of the \emph{average default counting process}
\eqn{L} under a transformation and a linear aggregation can be calculated with
\code{\link[=expected_value]{expected_value()}}; i.e. the value
\deqn{
  \mathbb{E}[diag(A^\top \cdot g(L_t))] , \quad t = (t_1, \ldots, t_m) \geq 0.
}
with \eqn{g : \mathbb{R} \to \mathbb{R}^p} \eqn{A = (a_1, \ldots, a_p) \in R^{m \times p}}.
\itemize{
\item For classes with an implementation of \code{probability_distribution}, \code{method == "prob"} can be
used. In this case the transformation \code{g} (generalized such that \eqn{g(\mathbb{R}^m) \in
  \mathbb{R}^{m \times p}}) should be provided via \code{.trans_v(x)} which takes an
\eqn{\mathbb{R}^m} vector and returns a \eqn{\mathbb{R}^{m\times p}} matrix. Furthermore, the
(diagonal of the) linear aggregation should be provided via \code{.lagg_ev(x)} which takes a
\eqn{\mathbb{R}^{m \times p}} matrix and returns an \eqn{\mathbb{R}^p} vector. Both functions
should be vectorized appropriately.
\item For all classes, \code{method == "prob"} can be used. In this case a function \code{.simulate_pv} should
be provided. This function should draw samples of \eqn{L_t^{(i)}} and  return the values of
\eqn{(a_j^\top \cdot g_j(L_t^{(i)}))} in a \eqn{\mathbb{R}^{n \times p}} matrix. A named list
of functions can be provided via \code{attrs} those should take a matrix of simulated pvs as
arguments; their results will be bound to the return values as attributes.
}

The methods \code{\link[=expected_pcds_equation]{expected_pcds_equation()}} and \code{\link[=expected_cdo_equation]{expected_cdo_equation()}} are convenience-wrappers for
expected \emph{portfolio CDS} and \emph{CDO} payoff-equations.
}

\examples{
parm <- ExMarkovParam(rmo::exQMatrix(rmo::AlphaStableBernsteinFunction(0.4), d = 5L))
simulate_adcp(parm, 1, n_sim = 10L)
simulate_adcp(parm, seq(25e-2, 5, by = 25e-2), n_sim = 10L)

expected_value(CuadrasAugeExtMO2FParam(
  dim = 50L, lambda = 0.05, rho = 0.4), 0.25,
  .trans_v = function(x) x, .lagg_ev = function(x) x)
expected_value(AlphaStableExtMO2FParam(
  dim = 50L, lambda = 0.05, rho = 0.4), seq(25e-2, 5, by = 25e-2),
  .trans_v = function(x) x, .lagg_ev = function(x) apply(x, 2L, mean))
expected_value(PoissonExtMO2FParam(
  dim = 50L, lambda = 0.05, rho = 0.4), 0.25,
  .trans_v = function(x) pmin(pmax(0.6 * x - 0.1, 0), 0.2),
  .lagg_ev = function(x) apply(x, 2L, mean))
expected_value(ExponentialExtMO2FParam(
  dim = 50L, lambda = 0.05, rho = 0.4), seq(25e-2, 5, by = 25e-2),
  .trans_v = function(x) pmin(pmax(0.6 * x - 0.1, 0), 0.2),
  .lagg_ev = function(x) apply(x, 2L, mean))

expected_value(CuadrasAugeExtMO2FParam(
  dim = 50L, lambda = 0.05, rho = 0.4), 0.25,
  method = "mc", n_sim = 1e4L,
  .simulate_pv = function(object, times, n_sim) simulate_adcp(object, times, n_sim = n_sim))
expected_value(CuadrasAugeExtMO2FParam(
  dim = 50L, lambda = 0.05, rho = 0.4), seq(25e-2, 5, by = 25e-2),
  method = "mc", n_sim = 1e4L,
  .simulate_pv = function(object, times, n_sim) simulate_adcp(object, times, n_sim = n_sim))
expected_value(CuadrasAugeExtMO2FParam(
  dim = 50L, lambda = 0.05, rho = 0.4), seq(25e-2, 5, by = 25e-2),
  function(x) pmin(pmax(0.6 * x - 0.1, 0), 0.2),
  method = "mc", n_sim = 1e4L,
  .simulate_pv = function(object, times, n_sim) simulate_adcp(object, times, n_sim = n_sim),
  attrs = list(sd = function(x) apply(x, 2L, function(y) sd(y) / sqrt(length(y)))))

expected_pcds_equation(
  AlphaStableExtMO2FParam(dim = 75, lambda = 0.05, rho = 0.6),
  times = seq(25e-2, 5, by = 25e-2), discount_factors = rep(1, 20L),
  recovery_rate = 0.4, coupon = 0.08, upfront = 0)
expected_pcds_equation(
  AlphaStableExtMO2FParam(dim = 75, lambda = 0.05, rho = 0.6),
  times = seq(25e-2, 5, by = 25e-2), discount_factors = rep(1, 20L),
  recovery_rate = 0.4, coupon = rep(0.08, 4), upfront = rep(0, 4))
expected_pcds_equation(
  AlphaStableExtMO2FParam(dim = 75, lambda = 0.05, rho = 0.6),
  times = seq(25e-2, 5, by = 25e-2), discount_factors = rep(1, 20L),
  recovery_rate = rep(0.4, 4), coupon = rep(0.08, 4), upfront = rep(0, 4))

expected_cdo_equation(
  ExtGaussian2FParam(dim = 75, lambda = 0.05, rho = 0.6),
  times = seq(25e-2, 5, by = 25e-2), discount_factors = rep(1, 20L),
  recovery_rate = 0.4, lower = c(0, 0.1, 0.2, 0.35),
  upper = c(0.1, 0.2, 0.35, 1), coupon = 0.08, upfront = 0
)

}
\seealso{
\linkS4class{ExMarkovParam} \linkS4class{ExMOParam} \linkS4class{ExtMOParam}
\linkS4class{CuadrasAugeExtMO2FParam} \linkS4class{AlphaStableExtMO2FParam}
\linkS4class{PoissonExtMO2FParam} \linkS4class{ExponentialExtMO2FParam}
\linkS4class{ExtArch2FParam} \linkS4class{ClaytonExtArch2FParam}
\linkS4class{FrankExtArch2FParam} \linkS4class{GumbelExtArch2FParam}
\linkS4class{JoeExtArch2FParam}
}
